// This code was by large generated by GPT4.

/*
The Factory Method design pattern is a creational pattern that provides an interface 
for creating objects in a superclass, but allows subclasses to alter the type of 
objects that will be created. This pattern lets a class defer instantiation to 
subclasses.


KEY COMPONENTS
1. PRODUCT:
The interface or abstract class defining the objects that the factory method creates.

2. CONCRETEPRODUCT: 
Concrete implementations of the Product interface.

3. CREATOR: 
The abstract class or interface that declares the factory method, 
which returns an object of type Product. The Creator may also provide 
some default implementation of the factory method.

4. CONCRETECREATOR: 
Subclasses of the Creator that override the factory method to return an 
instance of a ConcreteProduct.

STRUCTURE
Product: An interface for objects the factory method creates.
ConcreteProduct: Implements the Product interface.
Creator: Declares the factory method that returns a Product object.
ConcreteCreator: Implements the factory method to produce an instance of ConcreteProduct.
 */

namespace FactoryMethod
{
     // 5. CLIENT CODE:

    class Program
    {
        // The client code creates instances of RoadLogistics and SeaLogistics and
        // calls the PlanDelivery method to demonstrate the use of the Factory Method pattern.
        static void Main(string[] args)
        {
            Logistics logistics;

            // Plan road delivery
            logistics = new RoadLogistics();
            logistics.PlanDelivery();

            // Plan sea delivery
            logistics = new SeaLogistics();
            logistics.PlanDelivery();

            Console.ReadLine();
        }
    }

    /*
    BENEFITS OF THE FACTORY METHOD PATTERN
    Flexibility:
    The factory method pattern allows the code to be more flexible and reusable 
    by decoupling the code that uses the product from the code that creates 
    the product.
    
    Scalability: 
    Adding new products or creators requires minimal changes to existing code, 
    making the system scalable and easier to maintain.
    Single Responsibility Principle: The pattern adheres to the single responsibility 
    principle by delegating the responsibility of instantiating products to specific 
    creator classes.
    

    DRAWBACKS OF THE FACTORY METHOD PATTERN
    Complexity:
    The pattern can increase the overall complexity of the code by requiring 
    additional classes and interfaces.

    Overhead (extra computing or time resources): 
    In some cases, the pattern might introduce unnecessary overhead if not 
    used appropriately.
    The Factory Method pattern is a powerful tool for designing flexible and 
    scalable systems. It allows for the creation of objects without specifying 
    their exact classes, promoting loose coupling and adherence to design principles.
     */
}
