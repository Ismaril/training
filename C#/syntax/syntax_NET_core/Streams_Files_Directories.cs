using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace syntax_NET_core
{
    internal static class StreamsFilesDirectories
    {
        // How to work with files? Create some stream class. Then create some writer/reader class that takes
        //  as an argument the initial instance of stream class.
        public static void Main__()
        {
            // Since the actual executable is in bin/Debug/net5.0/ folder, we need to go back to the
            //  root folder of the project and then go to the Files folder.
            // Using ..\ syntax to go back in folder hierarchy.
            string fileDirectory = @"..\..\..\Files";
            string backupDirectory = @"..\..\..\BackUpTest";
            string filePathAndName = Path.Combine(
                $"{fileDirectory}",
                "data.bin"
                );

            Utilities utilities = new();
            utilities.PrintLine();

            // BE CAREFUL WHEN USING "USING" STATEMENT WITHOUT BRACKETS () AND {}. SEEMS IT DOES NOT
            //  WORK PROPERLY WITH FILESTREAM. IT DOES NOT CLOSE THE FILESTREAM AFTER USING IT.
            // The code in line below will either create a new file or overwrite the existing one.
            using (System.IO.FileStream filestream
                    = new(filePathAndName, FileMode.Create, FileAccess.Write))
            {
                // Write binary into filestream
                //filestream.Write("Nazdar".Select(x => (byte)x).ToArray(), 0, 6);

                // Better way to write binary into filestream
                BinaryWriter binaryWriter = new(filestream);
                binaryWriter.Write("Nazdar Woe");
                filestream.Flush();

                Console.WriteLine(
                $"CanRead: {filestream.CanRead},\n" +
                $"CanWrite: {filestream.CanWrite},\n" +
                $"CanSeek: {filestream.CanSeek},\n" +
                $"CanTimeout: {filestream.CanTimeout}"
                );
            }

            utilities.PrintLine();

            // Read binary from filestream
            using (System.IO.FileStream filestream2
                    = new(filePathAndName, FileMode.Open, FileAccess.Read))
            {
                BinaryReader binaryReader = new(filestream2);
                Console.WriteLine(binaryReader.ReadString());
            }

            utilities.PrintLine();

            // MEMORY STREAM
            // In example below you see that it is possible to write and read in the same
            //  using statement. It is because the memory stream is not a file but a memory.

            // Generated by copilot:
            /*
            In C#, a MemoryStream is a stream that is backed by memory rather than by a physical
                disk or network connection. This makes it faster for scenarios where you need to read
                and write data sequentially or randomly,
                as it doesn't have the overhead of disk I/O operations.
            */

            using (System.IO.MemoryStream memoryStream = new())
            {
                BinaryWriter binaryWriter = new(memoryStream);
                binaryWriter.Write("Nazdar Ty Woe!");
                memoryStream.Flush();
                memoryStream.Position = 0; // Return position (lets say a cursor) back to the beginning of the stream.

                BinaryReader binaryReader = new(memoryStream);
                Console.WriteLine(binaryReader.ReadString());
            }

            utilities.PrintLine();

            // STREAM READER AND WRITER
            // StreamReader and StreamWriter are used to read and write text files.
            string filePathAndName2 = Path.Combine(
                $"{fileDirectory}",
                "data.txt"
                );

            // Write data into file
            using (System.IO.StreamWriter streamWriter = new(filePathAndName2))
            {
                // Write line by line (each WriteLine method writes a new line)
                streamWriter.WriteLine("Cau Ty Woe!");
                streamWriter.WriteLine("Ahoj Ty Woe!");
                streamWriter.WriteLine("Nazdar Ty Woe!");
            }

            // Read data from file
            using (System.IO.StreamReader streamReader = new(filePathAndName2))
            {
                string line;
                while ((line = streamReader.ReadLine()) != null)
                {
                    Console.WriteLine(line);
                }
            }

            utilities.PrintLine();

            // ENCODING
            // To summarize, the code is registering a provider for a specific encoding in the .NET
            //  Core application, enabling the application to use the "windows-1250" encoding.
            System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);
            System.Text.Encoding encoding = System.Text.Encoding.GetEncoding("windows-1250");

            // UTF8 default encoding
            System.Text.Encoding encoding_UTF8 = System.Text.Encoding.UTF8;

            string filePathAndName3 = Path.Combine(
                $"{fileDirectory}",
                "data2.txt"
                );

            // Write data into file
            using (System.IO.StreamWriter streamWriter = new(filePathAndName3, false, encoding))
            {
                streamWriter.WriteLine("Se z toho posereš");

            }

            utilities.PrintLine();

            // FILE
            string filePathAndName4 = Path.Combine(
                $"{fileDirectory}",
                "data3.txt"
                );

            // Create a new file or overwrite the existing one with
            //  File class.
            using (System.IO.StreamWriter streamwriter
                    = System.IO.File.CreateText(filePathAndName4))
            {
                streamwriter.WriteLine("My jsme tady prvni cenova skupina!");
            }

            string fileBackupPathAndName =
                $"{backupDirectory}" +
                $"{Path.GetFileNameWithoutExtension(filePathAndName4)}" +
                $".txt"
                ;

            // Copy file using File.Copy method
            System.IO.File.Copy(
                sourceFileName: filePathAndName4,
                destFileName: fileBackupPathAndName,
                overwrite: true
                );

            utilities.PrintLine();

            // FILEINFO
            FileInfo fileInfo = new(filePathAndName4);
            fileInfo.CopyTo(
                destFileName: fileBackupPathAndName,
                overwrite: true
                );

            // GENERATED BY COPILOT:
            //q: What is the difference between File and FileInfo?
            //a: File is a static class that provides methods for creating, copying, deleting, moving,
            //  and opening files, and helps create a FileStream object. FileInfo is an instance class
            //  that provides instance methods for creating, copying, deleting, moving, and opening files,
            //  and helps create a FileStream object.
            //
            //q: What should I use, File or FileInfo?
            //a: If you are only going to perform one operation on a file, such as copying it, use the
            //  File class. If you are going to reuse the object several times, such as when you are
            //  working with the same file in a loop, use the FileInfo class.
            //

            utilities.PrintLine();

            // DIRECTORY
            /*
            In the context of software development, a "dump" often refers to a process where the
                contents of memory or storage are written out (or "dumped") for analysis.
            This is commonly used in debugging and troubleshooting scenarios.
            For example, a "core dump" is a type of data dump that records the memory of a
                computer program when it crashes, so that the error can be diagnosed.
            */

            // Dump file names in directory where are located the files of this project.
            string directoryPath = @"..\..\..\";
            string[] files = System.IO.Directory.GetFiles(directoryPath);
            foreach (string file in files)
            {
                Console.WriteLine(file);
            }

            utilities.PrintLine();

            // DIRECTORYINFO
            // As with fileinfo class, use directoryinfo class when you want to reuse the object
            //  several times, meaning if you are planning to do more operations on that object.
            DirectoryInfo directoryInfo = new(directoryPath);
            foreach (FileInfo fileInfo2 in directoryInfo.GetFiles())
            {
                Console.WriteLine(fileInfo2.Name);
            }

            utilities.PrintLine();

            // FILESYSTEMWATCHER
            // FileSystemWatcher is a class that monitors the file system and raises events when
            //  changes to the directory or file occur.
            // For your info, the events will be fired here only when the change happens during
            //  runtime of the program. It is not implemented here that it monitors the changes
            //  that happened before the program was run.
            FileSystemWatcher watcher = new();
            watcher.Path = fileDirectory;
            // Specify what exactly is monitored.
            watcher.Filter = "*.txt";
            // Specify what operation is monitored. (Change of file name in this case)
            watcher.NotifyFilter = NotifyFilters.FileName;
            // Sign up our custom events that will be raised when there is a change in the file.
            watcher.Renamed += Renamed_;
            watcher.Deleted += Deleted_;
            watcher.Created += Created_;
            // You can enable or disable the watcher with EnableRaisingEvents property.
            // If this was set to False, no events would be raised.
            watcher.EnableRaisingEvents = true;

        }

        /// <summary>
        /// Our custom event that will be raised when there is a change in the file.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        static void Renamed_(object sender, RenamedEventArgs e)
        {
            Console.WriteLine($"File {e.OldName} was renamed to {e.Name}");
        }

        /// <summary>
        /// Our custom event that will be raised when file is deleted.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        static void Deleted_(object sender, FileSystemEventArgs e)
        {
            Console.WriteLine($"File {e.Name} was deleted");
        }

        /// <summary>
        /// Our custom event that will be raised when file is created.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        static void Created_(object sender, FileSystemEventArgs e)
        {
            Console.WriteLine($"File {e.Name} was created");
        }
    }
}
