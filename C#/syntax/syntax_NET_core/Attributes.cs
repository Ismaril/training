using System.Diagnostics;
using System.Reflection;

/*
GENERATED BY GITHUB COPILOT
In C#, attributes are a type of metadata that can be 
added to the code to provide additional information which 
can be retrieved at runtime using reflection. 

They are used to impose conditions or to indicate to the 
compiler to perform certain additional tasks during compilation.
Attributes can be applied to assemblies, modules, types, 
methods, and properties. 
They are used for various purposes, such as:
1.	Serialization: Attributes can control how classes and members are serialized by the .NET Framework.
2.	Interoperability: Attributes can control how methods and types are used in COM interop.
3.	Conditional Compilation: Attributes can enable or disable code blocks depending on preprocessor settings.
4.	Declaring Properties: Some attributes can be used to declare properties for classes, methods, etc.

Here's an example of how to use an attribute in C#:
[System.Serializable]
public class SampleClass
{
    // Objects of this class can be serialized
}

In this example, the Serializable attribute is used to indicate 
that instances of SampleClass can be serialized. 
This is useful when you want to store the state of an object 
to a storage medium so that it can be recreated later.

*/

namespace syntax_NET_core
{
    internal static class Attributes
    {
        public static void Main__()
        {
            Utilities utilities = new();
            utilities.PrintLine();

            Customer customer = new Customer();
            customer.Id = 1;
            customer.Name = "John";

            Console.WriteLine(customer.GetName());

            utilities.PrintLine();

            // You can use the GetAttributeName method to get the name of the attribute.
            // Below will be listed the name of the attributes. (here names of properties)
            foreach (var item in AttributeHelper.GetAttributeName(customer))
                Console.WriteLine(item);

            utilities.PrintLine();

            customer.Name = "12345678910";
            ValidatorAttribute.Validate(customer);

        }
    }

    // With this DebuggerDisplay attribute in square brackets
    //  you can specify what will be shown in the debugger.
    // You can check that if you gonna debug this program and
    //  move the mouse over the customer instance.
    // It will make it easier for you to see values in Id and Name.
    // Without this attribute the instance would only show
    //  syntax_NET_core.Attributes.Customer.
    [DebuggerDisplay("Id = {Id}, Name = {Name}")]
    [MyAttribute_("Customers Class")]
    class Customer
    {
        [MyAttribute_("Customers Id")]
        public int Id { get; set; }

        [MyAttribute_("Customers Name")]
        [ValidatorAttribute(MaxLenght = 5)]
        public string Name { get; set; }

        // You can motivate user to use new method by marking the
        //  old one as obsolete.
        // You will see a warning when you call the old method.
        [Obsolete("Use GetNameWithId instead")]
        // [Obsolete("Use GetNameWithId instead", true)] // This will make the program not to compile.
        public string GetName()
        {
            return Name;
        }

        public string GetNameWithId()
        {
            return Id + " " + Name;
        }
    }

    // With AttributeUsage you can specify where the attribute can be used. 
    // With AttributeTargets.Property it can be used only on properties or classes.
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class)]
    // Create custom attribute, which will hold a name of the class or property.
    public class MyAttribute_ : Attribute
    {
        public string Name { get; set; }

        public MyAttribute_(string name)
        {
            Name = name;
        }
    }

    class AttributeHelper
    {
        public static IEnumerable<string> GetAttributeName(object item)
        {
            // GetProperties() will return all the properties of the object.
            foreach (var field in item.GetType().GetProperties())
            {
                var attribute = field.GetCustomAttributes(typeof(MyAttribute_), true).FirstOrDefault() as MyAttribute_;
                if (attribute != null)
                {
                    yield return attribute.Name;
                }
            }
        }
    }

    [AttributeUsage(AttributeTargets.Property)]
    public class ValidatorAttribute: Attribute
    {
        public int MaxLenght { get; set; }

        public static void Validate(object objParameter)
        {
            Type objType = objParameter.GetType();

            // Loop through all the properties.
            foreach (PropertyInfo propertyInfo in objType.GetProperties())
            {
                // For every property loop through all the attributes.
                foreach (Attribute attribute in propertyInfo.GetCustomAttributes(inherit: false))
                {
                    if (attribute is ValidatorAttribute)
                    {
                        ValidatorAttribute validatorAttribute = (ValidatorAttribute)attribute;
                        if (validatorAttribute.MaxLenght < propertyInfo.GetValue(objParameter).ToString().Length)
                            throw new Exception(
                                "Limitation of string length is "
                                + validatorAttribute.MaxLenght 
                                + " characters here."
                                );
                    }

                    
                }
            }

        }
    }
}
